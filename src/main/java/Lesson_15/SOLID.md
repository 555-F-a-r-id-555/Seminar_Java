Пять основных принципов SOLID:

1. Принцип единственной ответственности (Single Responsibility Principle)SRP:
   Каждый класс должен иметь только одну причину для изменения.
   Он должен быть ответственным только за одну функциональность.

   Пример: Рассмотрим класс `Employee`, который представляет сотрудника компании. Он должен отвечать только за данные и
   операции, связанные со сотрудником, например, управление персональными данными или вычисление заработной платы.
   Логика связанная с другими аспектами, например, управление отделами или отправка уведомлений, должна быть вынесена в
   другие классы.

2. Принцип открытости/закрытости (Open/Closed Principle)OCP:
   Программные сущности должны быть открыты для расширения, но закрыты для модификации. Это означает, что изменение
   поведения класса должно происходить путем добавления нового кода, а не изменения существующего.

   Пример: Предположим, у нас есть класс `Shape`, представляющий геометрическую фигуру. Мы можем создать подклассы для
   каждой конкретной фигуры, такие как `Circle`, `Rectangle`, `Triangle`, и т.д. При необходимости добавить новую
   фигуру, мы можем создать новый подкласс `NewShape`, расширяющий `Shape`, без необходимости изменять существующий код.

3. Принцип подстановки Барбары Лисков (Liskov Substitution Principle)LSP:
   Объекты должны быть заменяемыми своими подтипами без нарушения корректности программы. Это означает, что любая
   функция, работающая с базовым классом, должна работать и с его производными классами.

   Пример: У нас есть базовый класс `Animal` с методом `makeSound()`. У производных классов, таких как `Dog`, `Cat`
   и `Bird`, должны быть реализованы собственные версии метода `makeSound()`, чтобы каждое животное могло издавать свой
   уникальный звук. При этом все эти классы могут быть использованы вместо `Animal` в любом месте программы, где
   ожидается объект типа `Animal`.

4. Принцип разделения интерфейса (Interface Segregation Principle)ISP:
   Клиенты не должны зависеть от интерфейсов, которые они не используют. Интерфейсы должны быть максимально специфичными
   для клиентских потребностей.

   Пример: Рассмотрим интерфейс `Printer`, который имеет методы `print()` и `scan()`. Но если у нас есть клиент, который
   нуждается только в методе `print()`, ему не следует принуждать реализовывать метод `scan()`. Вместо этого мы можем
   разделить интерфейс на два: `Printable` (с методом `print()`) и `Scannable` (с методом `scan()`). Таким образом,
   клиенты могут реализовывать только интерфейс, который им необходим.

5. Принцип инверсии зависимостей (Dependency Inversion Principle)DIP:
   Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций. Абстракции не
   должны зависеть от деталей. Детали должны зависеть от абстракций.

   Пример: Представим класс `UserController`, который зависит от класса `DatabaseConnection`. Вместо того,
   чтобы `UserController` напрямую зависел от `DatabaseConnection`, мы можем ввести интерфейс `Database`, который будет
   реализовывать `DatabaseConnection`. Теперь `UserController` будет зависеть от интерфейса `Database`, а не от
   конкретной реализации, что позволяет легко изменить или заменить базу данных без изменения кода `UserController`.